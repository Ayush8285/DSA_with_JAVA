    # |  Problem                           | Type            | Technique / Strategy         | Time Complexity              | Space Complexity | Key Points / Insight
    1 | ğŸ” Binary Search in Rotated Array  | Searching      | Modified Binary Search       | O(log n)                     | O(1)              | Check sorted half to adjust search
    2 | ğŸ” Search in 2D Matrix             | Searching      | 1D Binary Search on 2D array | O(log (m Ã— n))               | O(1)              | Treat matrix as 1D using row/col mapping
    3 | ğŸ” Kth Largest Element in Array    | Searching/Heap | Min Heap of size k           | O(n log k)                   | O(k)              | Maintain k largest elements with min-heap
    4 | ğŸ”€ Merge Sort                      | Sorting        | Divide & Conquer             | O(n log n)                   | O(n)              | Stable sort using temp arrays
    5 | âš¡ Quick Sort                      | Sorting        | Partition (Divide & Conquer) | O(n log n) avg / O(nÂ²) worst | O(log n)          | In-place, unstable, fast in practice





ğŸ” Search Visualization Highlights:
Binary Search in Rotated Array: Identify sorted side, eliminate half.
2D Matrix Search: Map index â†’ row = mid / n, col = mid % n.
Kth Largest: Heap keeps only k largest numbers.


ğŸ”€ Sort Visualization Highlights:
Merge Sort: Top-down splitting, then merging sorted halves.
Quick Sort: Choose pivot â†’ partition â†’ recurse on left/right.